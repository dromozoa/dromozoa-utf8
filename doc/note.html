<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>実装メモ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
</head>
<style>
table {
  border-collapse: collapse;
}
th, td {
  border: 1px solid;
}
</style>
<body>

<h1>実装メモ</h1>

<h2>リンク</h2>

<ul>
  <li>RFC
    <ul>
      <li><a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a></li>
    </ul>
  </li>
</ul>

<h2>UTF-8エンコード</h2>

<div>
RFC 3629によって与えられているABNFを下記に示す。
冗長なエンコードと代用符号位置のエンコードが除外されている。
</div>

<pre>UTF8-octets = *( UTF8-char )
UTF8-char   = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4
UTF8-1      = %x00-7F
UTF8-2      = %xC2-DF UTF8-tail
UTF8-3      = %xE0 %xA0-BF UTF8-tail
            / %xE1-EC 2( UTF8-tail )
            / %xED %x80-9F UTF8-tail
            / %xEE-EF 2( UTF8-tail )
UTF8-4      = %xF0 %x90-BF 2( UTF8-tail )
            / %xF1-F3 3( UTF8-tail )
            / %xF4 %x80-8F 2( UTF8-tail )
UTF8-tail   = %x80-BF</pre>

<div>
展開して正規表現で書きくだす。
</div>

<pre>UTF8-1  = [\x00-\x7F]
UTF8-2  = [\xC2-\xDF] [\x80-\xBF]
UTF8-3a = [\xE0-\xE0] [\xA0-\xBF] [\x80-\xBF]
UTF8-3b = [\xE1-\xEC] [\x80-\xBF] [\x80-\xBF]
UTF8-3c = [\xED-\xED] [\x80-\x9F] [\x80-\xBF]
UTF8-3d = [\xEE-\xEF] [\x80-\xBF] [\x80-\xBF]
UTF8-4a = [\xF0-\xF0] [\x90-\xBF] [\x80-\xBF] [\x80-\xBF]
UTF8-4b = [\xF1-\xF3] [\x80-\xBF] [\x80-\xBF] [\x80-\xBF]
UTF8-4c = [\xF4-\xF4] [\x80-\x8F] [\x80-\xBF] [\x80-\xBF]</pre>

<div>
まず、UTF8-3bとUTF8-3dはまとめられるので、第1バイトを8種類の範囲に分類できる。
妥当でない領域も考慮すると、
</div>

<table>
  <tr><th>1</th><th>N</th></tr>
  <tr><td>00..7F</td><td>1</td></tr>
  <tr><td>80..C1</td><td></td></tr>
  <tr><td>C2..DF</td><td>2</td></tr>
  <tr><td>E0</td><td>3</td></tr>
  <tr><td>E1..EC</td><td>3</td></tr>
  <tr><td>ED</td><td>3</td></tr>
  <tr><td>EE..EF</td><td>3</td></tr>
  <tr><td>F0</td><td>4</td></tr>
  <tr><td>F1..F3</td><td>4</td></tr>
  <tr><td>F4</td><td>4</td></tr>
  <tr><td>F5..FF</td><td></td></tr>
</table>

<div>
また、第2バイト以降の範囲は6種類であることも判る。
演算後の値をテーブルとして保持する場合、第2バイト以降の範囲は7種類に分けられる（次表）。
テーブルは第1バイトだけから決定できる。
</div>

<table>
  <tr><th>1</th><th>2</th><th>3</th><th>4</th></tr>
  <tr><td>00..7F</td><td></td><td></td><td></td></tr>
  <tr><td>C2..DF</td><td>80..BF (A)</td><td></td><td></td></tr>
  <tr><td>E0</td><td>A0..BF (B2)</td><td>80..BF (A)</td><td></td></tr>
  <tr><td>E1..EC</td><td>80..BF (B)</td><td>80..BF (A)</td><td></td></tr>
  <tr><td>ED</td><td>80..9F (B3)</td><td>80..BF (A)</td><td></td></tr>
  <tr><td>EE..EF</td><td>80..BF (B)</td><td>80..BF (A)</td><td></td></tr>
  <tr><td>F0</td><td>90..BF (C2)</td><td>80..BF (B)</td><td>80..BF (A)</td></tr>
  <tr><td>F1..F3</td><td>80..BF (C)</td><td>80..BF (B)</td><td>80..BF (A)</td></tr>
  <tr><td>F4</td><td>80..8F (C3)</td><td>80..BF (B)</td><td>80..BF (A)</td></tr>
</table>

<h2>UTF-8デコード</h2>

<div>
1112064種類の整数を引数としてUTF-8バイト列を返すような関数であり、メモリ量を考えなければ表を使って高速な実装が可能である。
</div>

<table>
  <tr><th>first</th><th>last</th><th>count</th><th>size</th></tr>
  <tr><td>U+0000</td><td>U+007F</td><td>1</td><td>128 (0x0080)</td></tr>
  <tr><td>U+0080</td><td>U+07FF</td><td>2</td><td>1920 (0x0780)</td></tr>
  <tr><td>U+0800</td><td>U+D7FF</td><td>3</td><td>53248 (0xD000)</td></tr>
  <tr><td>U+E000</td><td>U+FFFF</td><td>3</td><td>8192 (0x2000)</td></tr>
  <tr><td>U+010000</td><td>U+10FFFF</td><td>4</td><td>1048576 (0x010000)</td></tr>
</table>

<div>
実験によれば、U+0001..U+07FFまでの区間を表にすると、消費メモリ量と速度のバランスがよいようだった。
</div>

<h2>Luaのビット演算</h2>

<table>
  <tr><th>Version</th><th>Impl</th></tr>
  <tr><td>Lua 5.1</td><td></td></tr>
  <tr><td>LuaJIT</td><td>function (bit)</td></tr>
  <tr><td>Lua 5.2</td><td>function (bit32)</td></tr>
  <tr><td>Lua 5.3</td><td>operator</td></tr>
</table>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    undefinedFamily: "sans-serif"
  }
});
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML"></script>
</body>
</html>
